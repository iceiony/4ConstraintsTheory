PHYSICS engine

First task of interest is in simulating the physical matching of tools to objects in 3D environments, as done by humans subjects.

In this approach it is required to considered the mathematical formalisation of objects matching using force closure [ForceClosure]. However, a shortcut to such physical interactions is to consider using a physics engine such as in [SimulationAsEngineOfSceneUnderstanding]. To some extent, it is believed that the human brain computes approximate of Newtonian laws. Similarly, physics engines do not compute exact friction, closure or gravity laws, but provide realistic results which can be experimented on. 

As suggested by [SimulationAsEngineOfSceneUnderstanding] we consider Bullet Physics for simulating the dynamics of object interaction under different forces and surface types. Other engines such as Open Dynamic Engine were considered, but have been found to be less portable or less likely to integrate with Matlab. 

BULLET INSTALL
Navigate to the engine's public source code and follow installation instructions  
https://github.com/bulletphysics/bullet3
Navigate to the matlab interface binding source code and follow instructions 
https://github.com/bminortx/Buckshot

FOLLOW BULLET INSTALL NOTES FROM: 
http://bulletphysics.org/mediawiki-1.5.8/index.php/Installation
cmake .. -G "Unix Makefiles" -DINSTALL_LIBS=ON -DBUILD_SHARED_LIBS=ON -DUSE_DOUBLE_PRECISION=ON

Bullet physics has more cross platform support and there is also some matlab integration for it. Also, I've read that the engine does well in dealing with the problems Jeremy mentioned (  surface tension and wobbling ).

It is worth mentioning that the engine can function with no 3D rendering ( as a standalone computation engine ). Although rendering is initially required to make sense of the code defining shapes and movements.

The physics engine code itself is sound, it compiles and installs easily on a machine. The matlab integration however is completely abysmal. After 3 days of hard work I managed to get the integration code to compile and run. It runs fine with no rendering but I can also use matlab figure rendering (which is extremely slow compared to normal 3D rendering).

Alternative to matlab, we would have to use C++ for writing the simulations. I would avoid it if possible.
C++ is not an easy language, the effect is that it shifts focus from the problem you are solving to dealing with the code complexities. 

There is an entire zoo of physics engines out there. The attached paper from 2007 states :
"Of  the  open  source  engines  the  Bullet  engine  provided  the  best 
results   overall,   outperforming   even   some   of   the   commercial engines."

It is not easy to find commercial engine prices. All of them require direct contact for a quote (an angine named Havok is said to charge $50k-$60k per game title ).
The most advanced engine for scientific simulation seems to be Vortex by CM-LABS. All other products are primarily aimed at game development. 

I will take a look at matlab specific solutions for rigid body dynamics (e.g. robotics toolkit )

Agreed, 2007 is a bit old. I've found another paper from 2013 (attached): [ref physics_comparison.png]
The table/figure in this email is a summary of the tests performed and overall results.
PhysX is a commercial game engine. I think it is worth adding that most commercial engines don't charge for non-commercial projects.

You are right, the SDKs don't come with source code. But the SDK's just control the physical world dynamics, not the actions of our agent. Therefore, we should be able to use commercial engines too.

The only concern is if the engine does not behave correctly in some aspect, it can not be mitigated or modified. For instance, if the friction laws used might require replacement. 



BASIC EXAMPLE IMPLEMENTATION
For testing the bullet engine we first define a simple example demo containing a basic tool and object. Figure [basic_demo_figures.png] shows the tool and objects defined. We initially use btConvexHullShape for defining the objects collision properties. Unfortunately, since bullet is primarily a game engine, the convex hull shape simply defines an approximation of the collision object, based on the object's mesh (figure [basic_demo_collision.png]). 
A better approach is to make use of a more computational expensive construct, namely btGImpactShape. The collision shape defined by this class can take the exact form of the object's mesh as per figure [badic_demo_exactCollision.png]

A magnitude of engine parameters can influence the effects of interaction between two objects:
 *Jittering/Shaking effects can be noticed if the  interaction margin between the two shapes is too small. Visually the effect is unrealistic even if the overall result is similar to a smooth movement one. On the other hand if the threshold margin is too large, the  object shapes would not be represented correctly with the tool not being able to properly fit in the object's gaps. 
 *The movement of tool and objects can be done multiple ways : 
   1. The tool can have 0 mass and be moved through updating it's location with each step. It is as if the tool simply teleports in the world to new locations. Zero mass tools are considered kinematic objects. As the tool's position collides with the object, the object is pushed in an opposite direction. This however results in sudden force impulses on the object since position updates carry no motion velocity information. 
   2. The tool can have mass and forces can be applied directly to it to control it's movement. This scenario is also undesirable. Tool movement control becomes difficult especially as the tool collides with the target object. The contact location creates forces in opposite directions for both tool and target object. It would be required for the tool to compensate such forces in order to not bounce of the target object.
   3. Tool can have mass but interact as a kinematic object. Objects with zero mass can not be moved by interacting forces. Fortunately, the object's collision properties can be changed to behave kinematic like, even as the object carries mass. As the object has mass, and collision is kinematic, moving the object through motion state forces will create more realistic interaction on collision. The technique however is still highly sensitive to simulation step size, collision shape margin and the speed of movement generated by the motion state.  However, as the simulation precission lowers, the shaking effect of interaction disapears . 
